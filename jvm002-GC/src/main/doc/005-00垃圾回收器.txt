》垃圾回收器：垃圾回收算法的具体实现
    ->Serial收集器：单线程收集器，在GC的时候，工作线程会停止。新生代收集器。
      使用场景：Client模式下 ，新生代收集器。
      搭配：CMS

    ->ParNew收集器：Serial 收集器的多线程版本，通常使用在Server模式下新生代的收集器。
      搭配：CMS
      使用：
      -XX:+UseConcMarkSweepGC  默认收集器
      -XX:+UseParNewGC强制指定

      单CPU 情况下ParNew 要强于Serial
      双核情况下并不能保证比Serial收集器更优秀。

      默认情况下GC 线程= CPU核数。可以通过：-XX:ParallelGCThreads （并行GC线程数）来限制GC 线程数。

    ->Parallel Scavenge收集器：复制算法
      注重吞吐量：吞吐量 = 运行用户代码时间 /(运行用户代码时间+ 垃圾回收时间)

      ParNew :收集器注重响应速度，适合与用户交互的程序，这样可以提高用户体验。
      Parallel Scavenge:更注重CPU 的使用率，适合后台运行的程序。

      参数：
      -XX:MaxGCPauseMillis:最大垃圾收集停顿时间。
      -XX:GCTimeRatio：直接设置吞吐量大小。  设置大于0 小于100 的整数 ，算法是 1/1+ 设置值 默认是99 吞吐量= 1/(1+99) 就是允许垃圾回收时间占比 程序运行总时间的1%
      如何设置成 19 则为 1/(1+19)    设置成 55 则为 1/(1+55)
      -XX:+UseAdaptiveSizePolicy :GC自适应调节。 可以省略各个细节配合，由JVM自己做内部调整。只需要简单的配置就能由虚拟机自己调节，这也是Parallel Scavenge收集器与
      ParNew 收集器的区别之一。
      只需要设置基本参数即可
      如-Xmx（堆最大内存），-XX:MaxGCPauseMillis(最大停顿时间)，-XX:GCTimeRatio (吞吐量) 等配置即可。

    ->Serial Old   收集器:是Serial 收集器老年代的版本。使用标记-整理算法。Client 模式下使用。CMS 收集器的后备预案。1.5之前配合Parallel Scavenge 收集器使用。

    ->Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本。使用多线程，以及标记-整理算法。 用于CPU 资源敏感场景。

    ->CMS收集器：标记-清除算法：获取停顿时间最短为目的的收集器，侧重用户体验。
      运行过程：
        1.初始标记（CMS inital mark）
            需要Stop The World :只标记与GC Roots 直接关联的对象。速度很快，只是进行GC Roots Tracing的过程。
        2.并发标记（CMS Concurrent mark）
            耗时长，但是跟用户线程同步运行。
        3.重新标记（CMS remark）
            需要Stop The World :修正并发标记期间，线程运行而导致标记变化的记录， 比初始标记时间稍长， 但远比并发标记时间短。
        4.并发清除（CMS concurrend sweep）

      特点：并发标记，低停顿。

      缺点：
        1.CUP敏感，当做并发操作的时候（并发标记，并发清除），虽然不会停止用户线程，但也会占用CPU 一部分线程来处理GC事宜（占用资源）
        同样会造成程序运行变慢。吞吐量降低。
        默认回收线程数：（CPU数量+3）/4

        2.无法处理浮动垃圾（并发清除的时候产生的垃圾。因为这个时候用户线程也在运行），只能留待下次垃圾回收的时候处理。
        无法等到老年代快满的时候才能进行回收， 因为垃圾收集过程中，还会有用户进行在运行 ，所以必须留有足够的空间给用户线程。

        3.因为使用标记清除算法，会产生大量的内存碎片， 大对象分配上会存在问题。
        老年代还有很多空间，但是连续空间不足，无法分配较大的对象。不得不提前一次进行Full GC
        为了解决这个问题CMS提供了
        -XX:+UseCMSCompactAtFullCollection开关参数（默认开启） 当进行FullGC的时候进行内存整理。
        -XX:CMSFullGCsBeforeCompaction:多少次不压缩的Full GC 之后提供一次压缩的Full GC 默认0 ，就是每次Full GC都会进行压缩整理操作。

    ->G1收集器：面向服务端的， 将来要替换CMS收集器的收集器
      特点：
        并行与并发：利用多核，多CPU 硬件优势，来减少STW 停顿时间。部分其他收集器原本需要停顿Java线程执行GC动作，G1可以通过并发的方式让Java线程继续执行。

        分代收集：仍然保存了分代收集的概念。不用配合其他收集器来单独就能整理堆内存。但是G1还是对刚产生的对象，存活一段时间的对象，以及多次GC以后依然存活的对象，进行了针对处理。
        这里需要注意，其他的收集器，都不能单独使用， 都针对新生代，老年代有不同的搭配来进行回收。可以从005垃圾回收器.png查看配合关系。

        空间整合：与CMS 的标记-整理算法不同。G1从整体上来看是基于 标记-整理算法。从局（两个Region之间）部看是基于 复制算法来完成的。
        G1收集器，是将整个内存空间，分块处理。G1 收集器不会产生内存碎片。

        可预测的停顿：G1 相对CMS 另一大优势。CMS 和G1 都致力于降低停顿时间。单G1还建立了，时间停顿预测模型。能让使用者明确指定一个长度为M的时间片段上，消耗在
        垃圾回收的时间不超过N毫秒。

        G1以前的收集器处理的都是整个年轻代，或者老年代。但是G1不同， G1将内存空间分配成划分正等大的独立的Region区域。虽然保留了新生代和老年代，但是新生代和老年代在物理上已经不是隔离的
        他们是一部分Region 的集合(可以不连续)的集合。


        虚拟机维护Remebered Set 来避免全堆扫描。
        G1每一个Region 都有一个与之对应的Remebered Set 虚拟机发现程序在对Reference 类型的数据，进行写操作时，会产生一个Write
        Barrier 暂时中断写操作。

      过程：
        初始标记（Inital Marking）
        并发标记（Concurrent Marking）
        最终标记（Final Marking）
        筛选回收（Living Data Counting and Evacuation）

》总结：











