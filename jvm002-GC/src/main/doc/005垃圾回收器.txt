》垃圾回收器：垃圾回收算法的具体实现
    ->Serial收集器：单线程收集器，在GC的时候，工作线程会停止。新生代收集器。
      使用场景：Client模式下 ，新生代收集器。
      搭配：CMS

    ->ParNew收集器：Serial 收集器的多线程版本，通常使用在Server模式下新生代的收集器。
      搭配：CMS
      使用：
      -XX:+UseConcMarkSweepGC  默认收集器
      -XX:+UseParNewGC强制指定

      单CPU 情况下ParNew 要强于Serial
      双核情况下并不能保证比Serial收集器更优秀。

      默认情况下GC 线程= CPU核数。可以通过：-XX:ParallelGCThreads （并行GC线程数）来限制GC 线程数。

    ->Parallel Scavenge收集器：复制算法
      注重吞吐量：吞吐量 = 运行用户代码时间 /(运行用户代码时间+ 垃圾回收时间)

      ParNew :收集器注重响应速度，适合与用户交互的程序，这样可以提高用户体验。
      Parallel Scavenge:更注重CPU 的使用率，适合后台运行的程序。

      参数：
      -XX:MaxGCPauseMillis:最大垃圾收集停顿时间。
      -XX:GCTimeRatio：直接设置吞吐量大小。  设置大于0 小于100 的整数 ，算法是 1/1+ 设置值 默认是99 吞吐量= 1/(1+99) 就是允许垃圾回收时间占比 程序运行总时间的1%
      如何设置成 19 则为 1/(1+19)    设置成 55 则为 1/(1+55)
      -XX:+UseAdaptiveSizePolicy :GC自适应调节。 可以省略各个细节配合，由JVM自己做内部调整。只需要简单的配置就能由虚拟机自己调节，这也是Parallel Scavenge收集器与
      ParNew 收集器的区别之一。
      只需要设置基本参数即可
      如-Xmx（堆最大内存），-XX:MaxGCPauseMillis(最大停顿时间)，-XX:GCTimeRatio (吞吐量) 等配置即可。

    -> Serial Old:是Serial 收集器老年代的版本。使用标记-整理算法。Client 模式下使用。CMS 收集器的后备预案。1.5之前配合Parallel Scavenge 收集器使用。

    -> Parallel Old 收集器：Parallel Scavenge 收集器的老年代版本。使用多线程，以及标记-整理算法。 用于CPU 资源敏感场景。

    -> CMS收集器：标记-算法：获取停顿时间最短为目的的收集器，侧重用户体验。
      运行过程：
        1.初始标记（CMS inital mark）
            需要Stop the World :只标记与GC Roots 直接关联的对象。速度很快，只是进行GC Roots Tracing的过程。
        2.并发标记（CMS Concurrent mark）
        3.重新标记（CMS remark）
        4.并发清除（CMS concurrend sweep）





