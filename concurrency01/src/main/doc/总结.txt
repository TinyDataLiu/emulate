展现并发的使用场景。
    1.涉及模式的使用用到了，生产者消费者模式。以及责任链模式。
    2.线程的状态分析
        共有六种状态
                NEW  线程新建状态,
                RUNNABLE 线程运行状态,
                BLOCKED 线程阻塞,
                WAITING 等待,
                TIMED_WAITING 时间等待,
                TERMINATED 终止;


        状态流转


                                        NEW
                                         |
                                         |
                                         |--start();
                                         |
                       WAITING--------RUNNABLE----------------------------------------------TIME_WAITING
                              |          |
                            wait()       |--- stop(); 不建议使用：相当于kill 操作
                            join()       |
                LockSupport.pack()       |--- interrupt(); 优雅停机
                                         |
                                         |---
                                         |
                                     TERMINATED

        说明
            NEW ---> RUNNABLE                       调用start() 方法。（这里需要注意， 有一个就绪的小状态，是由于线程争抢CPU造成）
            RUNNABLE ---> WAITING                   调用wait() ,join() ,LockSupport.pack();
            RUNNABLE ---> TIME_WAITING              调用wait(long time) ,join(long time) ,LockSupport.pack() ,sleep(long time);
            WAITING,TIME_WAITING ---> RUNNABLE      调用notify(); notifyAll(); unpark();
            RUNNABLE ---> TERMINATED                调用stop(); interrupt();
            BLOCKED                                 多个线程争抢锁的行为，会造成线程阻塞


 •  打开终端或者命令提示符，键入“jps”，（JDK1.5 提供的一个显示当前所有 java 进程 pid 的命令），可以获得相应进程的 pid
 •  根据上一步骤获得的 pid，继续输入 jstack pid（jstack 是 java 虚拟机自带的
 一种堆栈跟踪工具。jstack 用于打印出给定的 java 进程 ID 或 core file 或远程
 调试服务的 Java 堆栈信息）