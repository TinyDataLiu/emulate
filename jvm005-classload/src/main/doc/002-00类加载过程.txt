类加载过程

    》加载：加载是类加载(Class Loading)过程的一个阶段
    加载阶段完成以下三件事

    1.通过一个类的全限定名来获取此类的二进制流。（这里并未指明二进制须从Class文件中读取）
        》从zip包中读取，最终成为日后JAR,EAR,WAR格式的基础。
        》从网络中读取，这种场景最典型的应用就是Applet。
        》运行时计算生成，这里使用最多的就是动态代理技术。java.lang.reflect.Proxy中，就是用了ProxyGenerator.generateProxyClass
        来为特定接口生成为“*$Proxy”的代理类的二进制字节流。
        》由其他文件生成，典型应用场景就是JSP应用，由JSP生成Class文件。
        》从数据库中读取，这种场景很少见。

    2.将这个字节流所代表的静态存储结构转化为方法区的运行时的数据结构。

    3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类各种数据的访问入口。


    关于数组的加载：
    对于数组类而言， 情况略有不同， 数组类不通过类加载器创建。但数组类仍然与类加载器有密切关系。因为数组的元素类型最终要靠类加载器去创建。

    一个数组类，创建过程遵循以下规则：
        》如果数组的组件类型（元素）是引用类型，那就递归并有类加载器加载。
        》如果数组的组件类型不是引用类型（int[]数组），Java虚拟机将会把此数组标记为与引导类加载器关联。
        》数组可见性与它的组件类型的可见性一致，如果数组类不是引用类型，那数组的可见性默认为public。

        加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需要的格式存储在方法区之中，方法区中的数据存储格式由虚拟机自行定义，虚拟机规范为规定此区域的具体数据结构。
    然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotStop虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区中），这个
    对象将作为程序访问方法区中的这些类型的外部接口。

    》验证
        验证是连接阶段的第一步，确认Class文件字节流包含的信息，符合当前虚拟机的需求。
        1.文件格式验证
            >验证魔数 0XCAFEBABE开头。
            >主，次版本号是否在当前虚拟机处理范围之内。
            >常量池中的常量是否有不被支持的常量类型（检查常量的tag标志）。
            >指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
            >CONSTANT_Utf-8_info型的常量中是否有不符合UTF-8编码的数据。
            >Class文件中各个部分及文件本身是否有被删除或者附加的文件信息。

            文件合法性验证。
        2.元数据验证（主要是验证，类结构，父类验证，字段验证，方法合法性验证）
            >是否有父类（除了java.lang.Object 所有类都会有父类）
            >这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
            >如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
            >类中的字段，方法，是否与父类产生矛盾（如覆盖了父类的final 字段，或者出现不符合规则的方法重载，例如方法参数都一样，但是返回值却不同等）。

            主要对类的元数据信息进行语义验证，保证不存在不符合Java语言的元数据信息。
        3.字节码验证。
            通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行验证分析，保证被校验类的方法在运行时不会做出危害虚拟机的安全事件。如：

            >保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置一个int类型的数据，使用的时候却在long类型的数据载入本地变量表。
            >保证跳转指令不会跳转到方法体以外的字节码指令上。
            >保证方法体中的类型转换是有效的，例如：可以把一个子类的对象赋值给父类数据类型，这是安全的，但是把父类赋值给子类数据类型就是非法的。

        4.符号引用验证。
            符号引用验证可以看做是对类以外（常量池中各种符号引用）的信息进行匹配性验证。

            >符号引用中通过字符串描述的全限定名是否能找到对应的类。
            >在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法字段。
            >符号引用中的类，字段，方法的访问性（private,protected,public,default）是否可被当前类访问。

    》准备（为类变量设置初始值）
            准备阶段是正式为类变量分配内存并设置累初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），
        而不包括实例变量，实例变量将会在初始化的时候随着对象一起分配在Java堆中。期次，这里所说的初始值“通常情况”下数据类型的值是0；

        此阶段：
            public static int i = 123;          #i=0
            public static final int i = 123;    #i=123

    》解析
        将常量池中的符号引用替换为直接引用的过程。
        符号引用：
        直接引用：


    》初始化

