1.synchronized 分析
2.wait & notify
3.Lock 同步锁

JMM：原子性，一致性，有序性（解决这几个问题对os的封装）

导致以上问题的原因：
    CPU 缓存，处理器优化，指令重排序。

    限制处理器优化以及使用内存屏障。

JMM 操作模型规定线程访问主内存的时候必须先访问工作内存。

    线程->工作内存->主内存
    工作内存：线程独享的内存，对于每个线程来说，是完全隔离的完全独立的。

    JMM 抽象模型是对底层架构的统一规范，让应用开发者不用考虑底层架构的差异性，类似JVM。


    指令重排：
        》编译器优化重排序：导致可见性。
            -不改变单线程语义的前提下对程序对指令进行重排
            eg:int a=1;
               int b=a;
               这里不会存在重排序操作。
               int a =1;
               int b =1;
               这里会存在重排序。
            主要造成影响：可见性。
        》CPU指令重排：
            寄存器：
            高速缓存：
                L1:独享
                L2:独享
                L3:共享
            会导致缓存一致性问题 ：解决方案->MESI 协议。
            eg:
                x=0; 当我们将共享变量x 设置成0 的时候。
                cup0 S ->  E -> M
                cpu1

            当变量状态变更为M 的时候 其余CPU 将进入等待状态。
            当共享变量设置成I 的时候代表变量才能更新。


        》内存的乱序访问

    内存屏障：load barrier ,store barrier ,full barrier( X86 OS)

        内存屏障保证在屏障后执行的指令， 拿到的数据一定是同步后的数据。（已经刷新到主内存的数据。）

        1.保证数据可见性（相对于store barrier: barrier之前的数据都需要写到主内存，load barrier ：barrier 之前的数据都会从主内存中获取。）
        2.防止指令重排序。 barrier 之前的指令一定会在barrier之后执行。


    在Java中的体现。
        inline void OrderAccess::loadload()   { acquire(); }    //防止指令重排
        inline void OrderAccess::storestore() { release(); }    //防止指令重排

        inline void OrderAccess::release() {
          // Avoid hitting the same cache-line from
          // different threads.
          volatile jint local_dummy = 0;
        }

        inline void OrderAccess::loadstore()  { acquire(); }    //防止指令重排
        inline void OrderAccess::acquire() {
          volatile intptr_t local_dummy;
        #ifdef AMD64
          __asm__ volatile ("movq 0(%%rsp), %0" : "=r" (local_dummy) : : "memory");
        #else
          __asm__ volatile ("movl 0(%%esp),%0" : "=r" (local_dummy) : : "memory");
        #endif // AMD64
        }

        inline void OrderAccess::storeload()  { fence(); }      //防止指令重排且保证后续操作是原子的。
        inline void OrderAccess::fence() {
          if (os::is_MP()) { //判断是否为单核CPU
            // always use locked addl since mfence is sometimes expensive
        #ifdef AMD64
            __asm__ volatile [进制编译器对代码的优化]  ("#lock 缓存锁，或者是总线锁。【一个原子操作 后续响应操作是原子的， 防止】; addl $0,0(%%rsp)" : : : "cc", "memory");
        #else
            __asm__ volatile ("lock; addl $0,0(%%esp)" : : : "cc", "memory");
        #endif
          }
        }

        解决编译器的重排序以及CPU 指令重排序的问题。

        注：不同操作系统的指令不一样。

volatile分析：
        关键字提升可见性， 实际就是禁用OS 的指令重排。以及编译器重排。

        eg:
        int a=1;
        int volatile b = a;

        storestore （之前的数据已经刷新到主内存，且之后数据从主内存获取 a是从主内存中获取，而不是工作内存）
        b=a;
        storeload （可以理解为悲观锁）

synchronized 分析：
    》多线程的情况下加锁，保证线程的同步。
        可以解决，原子性，可见性，有序性问题。

    》synchronized 是怎么实现锁的？

    》为什么任何一个对象都可以成为锁？

    》锁存在什么地方
        对象头

    对象级别控制：monitorenter -> monitorexit 通过对象监视器来控制。
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: aload_0
         5: dup
         6: astore_1
         7: monitorenter
         8: aload_1
         9: monitorexit
        10: goto          18
        13: astore_2
        14: aload_1
        15: monitorexit
        16: aload_2
        17: athrow
        18: return

    方法级别控制：通过ACC_SYNCHRONIZED 来控制锁
         public synchronized void incr();
            descriptor: ()V
            flags: ACC_PUBLIC, ACC_SYNCHRONIZED
            Code:
              stack=0, locals=1, args_size=1
                 0: return
              LineNumberTable:
                line 27: 0
              LocalVariableTable:
                Start  Length  Slot  Name   Signature
                    0       1     0  this   Lcom/mrl/emulate/Demo;
        }




























































































下载：并发编程的艺术。