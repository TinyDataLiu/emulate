1.synchronized 分析
2.wait & notify
3.Lock 同步锁

JMM：原子性，一致性，有序性（解决这几个问题对os的封装）

导致以上问题的原因：
    CPU 缓存，处理器优化，指令重排序。

    限制处理器优化以及使用内存屏障。

JMM 操作模型规定线程访问主内存的时候必须先访问工作内存。

    线程->工作内存->主内存
    工作内存：线程独享的内存，对于每个线程来说，是完全隔离的完全独立的。

    JMM 抽象模型是对底层架构的统一规范，让应用开发者不用考虑底层架构的差异性，类似JVM。


    指令重排：
        》编译器优化重排序：导致可见性。
            -不改变单线程语义的前提下对程序对指令进行重排
            eg:int a=1;
               int b=a;
               这里不会存在重排序操作。
               int a =1;
               int b =1;
               这里会存在重排序。
            主要造成影响：可见性。
        》CPU指令重排：
            寄存器：
            高速缓存：
                L1:独享
                L2:独享
                L3:共享
            会导致缓存一致性问题 ：解决方案->MESI 协议。
            eg:
                x=0; 当我们将共享变量x 设置成0 的时候。
                cup0 S ->  E -> M
                cpu1

            当变量状态变更为M 的时候 其余CPU 将进入等待状态。
            当共享变量设置成I 的时候代表变量才能更新。


        》内存的乱序访问

    内存屏障：load barrier ,store barrier ,full barrier( X86 OS)
        1.保证数据可见性（相对于store barrier: barrier之前的数据都需要写到主内存，load barrier ：barrier 之前的数据都会从主内存中获取。）
        2.防止指令重排序。 barrier 之前的指令一定会在barrier之后执行。

    在Java中的体现。
        loadload()
        storestore()
        loadstore()
        storeload()
        解决编译器的重排序以及CPU 指令重排序的问题。

        volatile 关键字提升可见性， 实际就是禁用OS 的指令重排。以及编译器重排。

        eg:
        int a=1;
        int volatile b = a;

        storestore
        b=a;
        storeload



























